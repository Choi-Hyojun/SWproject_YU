# -*- coding: utf-8 -*-
"""SW Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dIkHVFkUPpn5i0AKlSQEL0tPqRviwyOb
"""

import random
import collections

def Initialization():
    tile_set = []
    board = []
    players = []


    for i in range(1,14):#타일뭉치를 만듭니다.
        tile_set.append("red_"+str(i).zfill(2))
        tile_set.append("red_"+str(i).zfill(2))
        tile_set.append("yellow_"+str(i).zfill(2))
        tile_set.append("yellow_"+str(i).zfill(2))
        tile_set.append("blue_"+str(i).zfill(2))
        tile_set.append("blue_"+str(i).zfill(2))
        tile_set.append("black_"+str(i).zfill(2))
        tile_set.append("black_"+str(i).zfill(2))
     
    random.shuffle(tile_set)

    player_num=int(input("플레이어의 수 : "))#플레이어의 숫자를 받습니다.
    for i in range(player_num):#플레이어들에게 타일 14개씩 나누어줍니다.
        hand=[]
        for j in range(14):
            hand.append(tile_set.pop())
        hand.sort()
        players.append([0,hand])
    
    return tile_set, board, players

def tile_color(tile):#각 타일의  숫자나 색깔을 표현하는 함수들입니다.
    return tile[:-3]

def tile_number(tile):
    return int(tile[-2:])

def tiles_color(tiles):#타일 집합의 숫자나 색깔 리스트를 반환하는 함수입니다. 
    colors=[]
    for i in range(len(tiles)):
        colors.append(tile_color(tiles[i]))
    return colors

def tiles_number(tiles):
    numbers=[]
    
    for i in range(len(tiles)):
        numbers.append(tile_number(tiles[i]))
    return numbers

def same_color(tiles):#타일들의 색깔이 모두 같은지 반환하는 함수입니다.
    colors=tiles_color(tiles)
    
    samecolor = True
    for i in range(len(tiles)-1):
        if(colors[i]!=colors[i+1]):
            samecolor = False

    return samecolor

def same_number(tiles):#타일들의 숫자가 모두 같은지 반환하는 함수입니다.
    numbers = tiles_number(tiles)
    
    samenumber = True
    for i in range(len(tiles)-1):
        if numbers[i] != numbers[i+1]:
            samenumber = False

    return samenumber

def different_color(tiles):#타일들의 색깔이 모두 다른지 반환하는 함수입니다.
    colors = tiles_color(tiles)
    color_num = collections.Counter(colors)
    differentcolor = True
    if color_num['red']>1 or color_num['yellow']>1 or color_num['blue']>1 or color_num['black']>1:
        differentcolor= False
    return differentcolor

def number_in_a_row(tiles):#타일들의 숫자가 연속하는지 반환하는 함수입니다.
    numbers = tiles_number(tiles)
    numbers.sort()
    
    numberinarow = True
    for i in range(len(tiles)-1):
        if numbers[i]+1 != numbers[i+1]:
            numberinarow = False
    return numberinarow

def available_tiles(tiles):#타일들이 루미큐브 규칙상 가능한 패인지 반환합니다.
    if(same_number(tiles)):
        return different_color(tiles)
    
    elif(same_color(tiles)):
        return number_in_a_row(tiles)
    else:
        return False

def able_to_register(tiles):#처음 등록할 때 등록이 가능한지 아닌지 반환합니다.
    if sum(tiles_number(tiles))<30:
        return False
    
    return available_tiles(tiles)

def registration(player, board):
    if player[0] != 0:
        print('Already registered player.')
        return
        
    else:
        while True:
            tiles = input("제출할 타일들 : (i.e. red_10 blue_03)")
            tiles = tiles.split()
            for tile in tiles:
                if tile not in player[1]:
                    print("잘못된 타일을 입력했습니다.")
                    continue
            if able_to_register(tiles):
                board.append(list(tiles))
                break
            else:
                print("등록할 수 없습니다. 다시 입력해주세요")
        player[0]=1
        for tile in tiles:
            player[1].remove(tile)

def receive_tile(players, order, tile_set):
    players[order][1].append(tile_set.pop()) 
    players[order][1].sort()

def print_player(players, order):
    print(players[order][1])

def print_board(board):
    for tiles in board:
        print(tiles)

def board_able(board):

    temp_board = board

    if len(temp_board)==0:
        return True

    minnum = 15
    mintile = ""
    for tile in temp_board:
        if tile_number(tile)<minnum:
            mintile = tile
            minnum = tile_number(tile)
    #숫자가 가장 낮은 타일을 찾는다

    able_sets = []

    min_tiles = []
    for tile in temp_board:
        if tile_number(tile)==minnum:
            min_tiles.append(tile)

    #같은 숫자끼리 집합을 만들고 서로 다른 색깔의 타일의 개수가 3개면 unique하게 정해지고 4개면 5가지 경우를 가짐
    temp_diff=[]
    for color in ["red", "blue", "black", "yellow"]:
        for tile in min_tiles:
            if tile_color(tile)==color:
                temp_diff.append(tile)
                break
    
    if len(temp_diff) == 3:
        for tile in temp_diff:
            temp_board.pop(tile)
        able, part_set = board_able(temp_board)
        if able:
            part_set.append(temp_diff)
            return True, part_set
    elif len(temp_diff) == 4:
        for color in ["red", "blue", "black"]:
            able_sets.append(color+"_"+str(minnum))




    samecolors = []
    mincolor = tile_color(mintile)
    temp_num = minnum
    while 1:#가장 숫자가 낮은 타일에서 같은색깔이고 이웃한 숫자를 가진 타일을 추가하며 able_sets에 추가함.
        check = True
        for tile in temp_board:
            if tile_color(tile)==mincolor and tile_number(tile)==temp_num:
                samecolors.append(tile)
                temp_num+=1
                check = False
                temp_board.pop(tile)
                if len(samecolors)>=3:
                    for tile1 in samecolors:
                        able_sets.append(tile1)
                    able, part_set = board_able(temp_board)#재귀적으로 타일들이 규칙상 보드에서 가능한지 체크하고 가능하면 현재의 타일시리즈와 함께 return
                    if able:
                        part_set.append(able_sets)
                        return True, part_set

                break
        if check:
            break
    return False, []

def game(tile_set,board, players):
    
    order = 0
    while True:
        print("Player "+str(order+1)+" tiles:")
        print_player(players, order)
        print("board:")
        print_board()
        if players[order][0] == 0:#등록절차
            regist = ""
            while True:
                regist = input("등록하시겠습니까 ? (y or n)")
                if regist == "n":
                    receive_tile(players, order, tile_set)
                    break
                elif regist == "y":
                    registration(players[order], board)
                    players[order][0]=1
                    break
                elif regist == "terminate":
                    return
                else:
                    print("잘 못 입력하셨습니다")
                    
        else:
            submit=""
            while True:
                submit = input("타일을 제출하시겠습니까? (y or n)")
                if submit == "n":
                    receive_tile(order)
                    break
                elif submit == "y":
                    tiles = input("제출할 타일들을 입력해주세요.")
                    tiles = tiles.split()
                    #submit_tiles(board, tiles)
                elif submit == "terminate":
                    return
                else:
                    print("잘 못 입력하셨습니다")
        if len(players[order][1]) == 0:
            print("Player "+str(order+1)+" Win!")
            break
        order=(order+1)%len(players)

#tile_set,board, players = Initialization()
#game(tile_set,board, players)



if __name__=="__main__":
    Initialization()